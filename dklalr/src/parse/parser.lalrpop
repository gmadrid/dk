use crate::parse::ast::{ArgsNode, ArgNode, ArgTailNode, BoolNode, CallNode,
                 CallTailNode, ProgramNode,
                 StmtNode, StmtsNode, StmtTailNode, ValueNode};
use crate::parse::lexer;

grammar;

pub Program : ProgramNode = {
    Stmts => {
        let mut m_stmts = <>;
        m_stmts.0.reverse();
        ProgramNode(m_stmts.0)
    }
}

Stmts : StmtsNode = {
    <s:Stmt> <ss:Stmts> => {
        let mut m_ss = ss;
        // NOTE: we are building this in reverse.
        m_ss.0.push(s);
        m_ss
    },
    => StmtsNode(Vec::new())
}

Stmt : StmtNode = {
    <id:IDENT> <tail:StmtTail> => {
        match tail {
            StmtTailNode::Assign(cn) => StmtNode::Assign(id, cn),
            StmtTailNode::Call(args) => StmtNode::Call(CallNode(id, args)),
        }
    }
}

StmtTail : StmtTailNode = {
    EQ <Call> => StmtTailNode::Assign(<>),
    CallTail => StmtTailNode::Call(<>.0),
}

Call : CallNode = {
    <id:IDENT> <args:CallTail> => {
        CallNode(id.to_string(), args.0)
    }
}

CallTail : CallTailNode = {
    LPAREN <Args> RPAREN => CallTailNode(<>)
}

Args: ArgsNode = {
    <aas:Args> COMMA <a:Arg> => { let mut maas = aas; maas.0.push(a); maas },
    <Arg> => ArgsNode(vec![<>])
}

Arg: ArgNode = {
    <v:Value> <tail:ArgTail> => {
        if tail.0.is_some() {
            if let ValueNode::Ident(id) = v {
                ArgNode(tail.0.unwrap(), Some(id))
            } else {
                panic!("Expected IDENT for name of argument.")
            }
        } else {
            ArgNode(v, None)
        }
    }
}

ArgTail: ArgTailNode = {
    EQ <Value> => ArgTailNode(Some(<>)),
    => ArgTailNode(None),
}

Value: ValueNode = {
    IDENT => ValueNode::Ident(<>.to_string()),
    NUMBER => ValueNode::Number(<>),
    STRING => ValueNode::String(<>),
    Bool => ValueNode::Bool(<>.0),
}

Bool: BoolNode = {
    TRUE => BoolNode(true),
    FALSE => BoolNode(false),
}

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Token {
        COMMA => lexer::Token::Comma,
        EQ => lexer::Token::Eq,
        FALSE => lexer::Token::False,
        IDENT => lexer::Token::Ident(<String>),
        LPAREN => lexer::Token::LParen,
        NUMBER => lexer::Token::Number(<i32>),
        RPAREN => lexer::Token::RParen,
        STRING => lexer::Token::String(<String>),
        TRUE => lexer::Token::True,
    }
}